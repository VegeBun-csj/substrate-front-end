yarn run v1.22.11
$ node --use_strict index.js
Connected to Substrate
Balance existentialDeposit: 500
Alice Account: {"nonce":1,"consumers":0,"providers":1,"sufficients":0,"data":{"free":"0x00000000000000000ffc728153c6262c","reserved":0,"miscFrozen":0,"feeFrozen":0}}
Alice free balance in readable format: 1.1519 MUnit
Subscribed to Alice account.
Alice Account (sub): 1151921504481846828
Chain Metadata: {
  "magicNumber": 1635018093,
  "metadata": {
    "v13": {
      "modules": [
        {
          "name": "System",
          "storage": {
            "prefix": "System",
            "items": [
              {
                "name": "Account",
                "modifier": "Default",
                "type": {
                  "map": {
                    "hasher": "Blake2_128Concat",
                    "key": "AccountId",
                    "value": "AccountInfo",
                    "linked": false
                  }
                },
                "fallback": "0x0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
                "docs": [
                  " The full account information for a particular account ID."
                ]
              },
              {
                "name": "ExtrinsicCount",
                "modifier": "Optional",
                "type": {
                  "plain": "u32"
                },
                "fallback": "0x00",
                "docs": [
                  " Total extrinsics count for the current block."
                ]
              },
              {
                "name": "BlockWeight",
                "modifier": "Default",
                "type": {
                  "plain": "ConsumedWeight"
                },
                "fallback": "0x000000000000000000000000000000000000000000000000",
                "docs": [
                  " The current weight for the block."
                ]
              },
              {
                "name": "AllExtrinsicsLen",
                "modifier": "Optional",
                "type": {
                  "plain": "u32"
                },
                "fallback": "0x00",
                "docs": [
                  " Total length (in bytes) for all extrinsics put together, for the current block."
                ]
              },
              {
                "name": "BlockHash",
                "modifier": "Default",
                "type": {
                  "map": {
                    "hasher": "Twox64Concat",
                    "key": "BlockNumber",
                    "value": "Hash",
                    "linked": false
                  }
                },
                "fallback": "0x0000000000000000000000000000000000000000000000000000000000000000",
                "docs": [
                  " Map of block numbers to block hashes."
                ]
              },
              {
                "name": "ExtrinsicData",
                "modifier": "Default",
                "type": {
                  "map": {
                    "hasher": "Twox64Concat",
                    "key": "u32",
                    "value": "Bytes",
                    "linked": false
                  }
                },
                "fallback": "0x00",
                "docs": [
                  " Extrinsics data for the current block (maps an extrinsic's index to its data)."
                ]
              },
              {
                "name": "Number",
                "modifier": "Default",
                "type": {
                  "plain": "BlockNumber"
                },
                "fallback": "0x00000000",
                "docs": [
                  " The current block number being processed. Set by `execute_block`."
                ]
              },
              {
                "name": "ParentHash",
                "modifier": "Default",
                "type": {
                  "plain": "Hash"
                },
                "fallback": "0x0000000000000000000000000000000000000000000000000000000000000000",
                "docs": [
                  " Hash of the previous block."
                ]
              },
              {
                "name": "Digest",
                "modifier": "Default",
                "type": {
                  "plain": "DigestOf"
                },
                "fallback": "0x00",
                "docs": [
                  " Digest of the current block, also part of the block header."
                ]
              },
              {
                "name": "Events",
                "modifier": "Default",
                "type": {
                  "plain": "Vec<EventRecord>"
                },
                "fallback": "0x00",
                "docs": [
                  " Events deposited for the current block."
                ]
              },
              {
                "name": "EventCount",
                "modifier": "Default",
                "type": {
                  "plain": "EventIndex"
                },
                "fallback": "0x00000000",
                "docs": [
                  " The number of events in the `Events<T>` list."
                ]
              },
              {
                "name": "EventTopics",
                "modifier": "Default",
                "type": {
                  "map": {
                    "hasher": "Blake2_128Concat",
                    "key": "Hash",
                    "value": "Vec<(BlockNumber,EventIndex)>",
                    "linked": false
                  }
                },
                "fallback": "0x00",
                "docs": [
                  " Mapping between a topic (represented by T::Hash) and a vector of indexes",
                  " of events in the `<Events<T>>` list.",
                  "",
                  " All topic vectors have deterministic storage locations depending on the topic. This",
                  " allows light-clients to leverage the changes trie storage tracking mechanism and",
                  " in case of changes fetch the list of events of interest.",
                  "",
                  " The value has the type `(T::BlockNumber, EventIndex)` because if we used only just",
                  " the `EventIndex` then in case if the topic has the same contents on the next block",
                  " no notification will be triggered thus the event might be lost."
                ]
              },
              {
                "name": "LastRuntimeUpgrade",
                "modifier": "Optional",
                "type": {
                  "plain": "LastRuntimeUpgradeInfo"
                },
                "fallback": "0x00",
                "docs": [
                  " Stores the `spec_version` and `spec_name` of when the last runtime upgrade happened."
                ]
              },
              {
                "name": "UpgradedToU32RefCount",
                "modifier": "Default",
                "type": {
                  "plain": "bool"
                },
                "fallback": "0x00",
                "docs": [
                  " True if we have upgraded so that `type RefCount` is `u32`. False (default) if not."
                ]
              },
              {
                "name": "UpgradedToTripleRefCount",
                "modifier": "Default",
                "type": {
                  "plain": "bool"
                },
                "fallback": "0x00",
                "docs": [
                  " True if we have upgraded so that AccountInfo contains three types of `RefCount`. False",
                  " (default) if not."
                ]
              },
              {
                "name": "ExecutionPhase",
                "modifier": "Optional",
                "type": {
                  "plain": "Phase"
                },
                "fallback": "0x00",
                "docs": [
                  " The execution phase of the block."
                ]
              }
            ]
          },
          "calls": [
            {
              "name": "fill_block",
              "args": [
                {
                  "name": "_ratio",
                  "type": "Perbill"
                }
              ],
              "docs": [
                " A dispatch that will fill the block weight up to the given ratio."
              ]
            },
            {
              "name": "remark",
              "args": [
                {
                  "name": "_remark",
                  "type": "Bytes"
                }
              ],
              "docs": [
                " Make some on-chain remark.",
                "",
                " # <weight>",
                " - `O(1)`",
                " # </weight>"
              ]
            },
            {
              "name": "set_heap_pages",
              "args": [
                {
                  "name": "pages",
                  "type": "u64"
                }
              ],
              "docs": [
                " Set the number of pages in the WebAssembly environment's heap.",
                "",
                " # <weight>",
                " - `O(1)`",
                " - 1 storage write.",
                " - Base Weight: 1.405 µs",
                " - 1 write to HEAP_PAGES",
                " # </weight>"
              ]
            },
            {
              "name": "set_code",
              "args": [
                {
                  "name": "code",
                  "type": "Bytes"
                }
              ],
              "docs": [
                " Set the new runtime code.",
                "",
                " # <weight>",
                " - `O(C + S)` where `C` length of `code` and `S` complexity of `can_set_code`",
                " - 1 storage write (codec `O(C)`).",
                " - 1 call to `can_set_code`: `O(S)` (calls `sp_io::misc::runtime_version` which is expensive).",
                " - 1 event.",
                " The weight of this function is dependent on the runtime, but generally this is very expensive.",
                " We will treat this as a full block.",
                " # </weight>"
              ]
            },
            {
              "name": "set_code_without_checks",
              "args": [
                {
                  "name": "code",
                  "type": "Bytes"
                }
              ],
              "docs": [
                " Set the new runtime code without doing any checks of the given `code`.",
                "",
                " # <weight>",
                " - `O(C)` where `C` length of `code`",
                " - 1 storage write (codec `O(C)`).",
                " - 1 event.",
                " The weight of this function is dependent on the runtime. We will treat this as a full block.",
                " # </weight>"
              ]
            },
            {
              "name": "set_changes_trie_config",
              "args": [
                {
                  "name": "changes_trie_config",
                  "type": "Option<ChangesTrieConfiguration>"
                }
              ],
              "docs": [
                " Set the new changes trie configuration.",
                "",
                " # <weight>",
                " - `O(1)`",
                " - 1 storage write or delete (codec `O(1)`).",
                " - 1 call to `deposit_log`: Uses `append` API, so O(1)",
                " - Base Weight: 7.218 µs",
                " - DB Weight:",
                "     - Writes: Changes Trie, System Digest",
                " # </weight>"
              ]
            },
            {
              "name": "set_storage",
              "args": [
                {
                  "name": "items",
                  "type": "Vec<KeyValue>"
                }
              ],
              "docs": [
                " Set some items of storage.",
                "",
                " # <weight>",
                " - `O(I)` where `I` length of `items`",
                " - `I` storage writes (`O(1)`).",
                " - Base Weight: 0.568 * i µs",
                " - Writes: Number of items",
                " # </weight>"
              ]
            },
            {
              "name": "kill_storage",
              "args": [
                {
                  "name": "keys",
                  "type": "Vec<Key>"
                }
              ],
              "docs": [
                " Kill some items from storage.",
                "",
                " # <weight>",
                " - `O(IK)` where `I` length of `keys` and `K` length of one key",
                " - `I` storage deletions.",
                " - Base Weight: .378 * i µs",
                " - Writes: Number of items",
                " # </weight>"
              ]
            },
            {
              "name": "kill_prefix",
              "args": [
                {
                  "name": "prefix",
                  "type": "Key"
                },
                {
                  "name": "_subkeys",
                  "type": "u32"
                }
              ],
              "docs": [
                " Kill all storage items with a key that starts with the given prefix.",
                "",
                " **NOTE:** We rely on the Root origin to provide us the number of subkeys under",
                " the prefix we are removing to accurately calculate the weight of this function.",
                "",
                " # <weight>",
                " - `O(P)` where `P` amount of keys with prefix `prefix`",
                " - `P` storage deletions.",
                " - Base Weight: 0.834 * P µs",
                " - Writes: Number of subkeys + 1",
                " # </weight>"
              ]
            },
            {
              "name": "remark_with_event",
              "args": [
                {
                  "name": "remark",
                  "type": "Bytes"
                }
              ],
              "docs": [
                " Make some on-chain remark and emit event.",
                "",
                " # <weight>",
                " - `O(b)` where b is the length of the remark.",
                " - 1 event.",
                " # </weight>"
              ]
            }
          ],
          "events": [
            {
              "name": "ExtrinsicSuccess",
              "args": [
                "DispatchInfo"
              ],
              "docs": [
                " An extrinsic completed successfully. \\[info\\]"
              ]
            },
            {
              "name": "ExtrinsicFailed",
              "args": [
                "DispatchError",
                "DispatchInfo"
              ],
              "docs": [
                " An extrinsic failed. \\[error, info\\]"
              ]
            },
            {
              "name": "CodeUpdated",
              "args": [],
              "docs": [
                " `:code` was updated."
              ]
            },
            {
              "name": "NewAccount",
              "args": [
                "AccountId"
              ],
              "docs": [
                " A new \\[account\\] was created."
              ]
            },
            {
              "name": "KilledAccount",
              "args": [
                "AccountId"
              ],
              "docs": [
                " An \\[account\\] was reaped."
              ]
            },
            {
              "name": "Remarked",
              "args": [
                "AccountId",
                "Hash"
              ],
              "docs": [
                " On on-chain remark happened. \\[origin, remark_hash\\]"
              ]
            }
          ],
          "constants": [
            {
              "name": "BlockWeights",
              "type": "BlockWeights",
              "value": "0x00f2052a0100000000204aa9d1010000405973070000000001c06e96a62e010000010098f73e5d010000010000000000000000405973070000000001c0f6e810a30100000100204aa9d1010000010088526a740000004059730700000000000000",
              "docs": [
                " Block & extrinsics weights: base values and limits."
              ]
            },
            {
              "name": "BlockLength",
              "type": "BlockLength",
              "value": "0x00003c000000500000005000",
              "docs": [
                " The maximum length of a block (in bytes)."
              ]
            },
            {
              "name": "BlockHashCount",
              "type": "BlockNumber",
              "value": "0x60090000",
              "docs": [
                " Maximum number of block number to block hash mappings to keep (oldest pruned first)."
              ]
            },
            {
              "name": "DbWeight",
              "type": "RuntimeDbWeight",
              "value": "0x40787d010000000000e1f50500000000",
              "docs": [
                " The weight of runtime database operations the runtime can invoke."
              ]
            },
            {
              "name": "Version",
              "type": "RuntimeVersion",
              "value": "0x346e6f64652d74656d706c617465346e6f64652d74656d706c61746501000000640000000100000028df6acb689907609b0300000037e397fc7c91f5e40100000040fe3ad401f8959a05000000d2bc9897eed08f1502000000f78b278be53f454c02000000dd718d5cc53262d401000000ab3c0572291feb8b01000000ed99c5acb25eedf502000000bc9d89904f5b923f0100000037c8bb1350a9a2a80100000001000000",
              "docs": [
                " Get the chain's current version."
              ]
            },
            {
              "name": "SS58Prefix",
              "type": "u16",
              "value": "0x2a00",
              "docs": [
                " The designated SS85 prefix of this chain.",
                "",
                " This replaces the \"ss58Format\" property declared in the chain spec. Reason is",
                " that the runtime should know about the prefix in order to make use of it as",
                " an identifier of the chain."
              ]
            }
          ],
          "errors": [
            {
              "name": "InvalidSpecName",
              "docs": [
                " The name of specification does not match between the current runtime",
                " and the new runtime."
              ]
            },
            {
              "name": "SpecVersionNeedsToIncrease",
              "docs": [
                " The specification version is not allowed to decrease between the current runtime",
                " and the new runtime."
              ]
            },
            {
              "name": "FailedToExtractRuntimeVersion",
              "docs": [
                " Failed to extract the runtime version from the new runtime.",
                "",
                " Either calling `Core_version` or decoding `RuntimeVersion` failed."
              ]
            },
            {
              "name": "NonDefaultComposite",
              "docs": [
                " Suicide called when the account has non-default composite data."
              ]
            },
            {
              "name": "NonZeroRefCount",
              "docs": [
                " There is a non-zero reference count preventing the account from being purged."
              ]
            }
          ],
          "index": 0
        },
        {
          "name": "RandomnessCollectiveFlip",
          "storage": {
            "prefix": "RandomnessCollectiveFlip",
            "items": [
              {
                "name": "RandomMaterial",
                "modifier": "Default",
                "type": {
                  "plain": "Vec<Hash>"
                },
                "fallback": "0x00",
                "docs": [
                  " Series of block headers from the last 81 blocks that acts as random seed material. This",
                  " is arranged as a ring buffer with `block_number % 81` being the index into the `Vec` of",
                  " the oldest hash."
                ]
              }
            ]
          },
          "calls": null,
          "events": null,
          "constants": [],
          "errors": [],
          "index": 1
        },
        {
          "name": "Timestamp",
          "storage": {
            "prefix": "Timestamp",
            "items": [
              {
                "name": "Now",
                "modifier": "Default",
                "type": {
                  "plain": "Moment"
                },
                "fallback": "0x0000000000000000",
                "docs": [
                  " Current time for the current block."
                ]
              },
              {
                "name": "DidUpdate",
                "modifier": "Default",
                "type": {
                  "plain": "bool"
                },
                "fallback": "0x00",
                "docs": [
                  " Did the timestamp get updated in this block?"
                ]
              }
            ]
          },
          "calls": [
            {
              "name": "set",
              "args": [
                {
                  "name": "now",
                  "type": "Compact<Moment>"
                }
              ],
              "docs": [
                " Set the current time.",
                "",
                " This call should be invoked exactly once per block. It will panic at the finalization",
                " phase, if this call hasn't been invoked by that time.",
                "",
                " The timestamp should be greater than the previous one by the amount specified by",
                " `MinimumPeriod`.",
                "",
                " The dispatch origin for this call must be `Inherent`.",
                "",
                " # <weight>",
                " - `O(1)` (Note that implementations of `OnTimestampSet` must also be `O(1)`)",
                " - 1 storage read and 1 storage mutation (codec `O(1)`). (because of `DidUpdate::take` in `on_finalize`)",
                " - 1 event handler `on_timestamp_set`. Must be `O(1)`.",
                " # </weight>"
              ]
            }
          ],
          "events": null,
          "constants": [
            {
              "name": "MinimumPeriod",
              "type": "Moment",
              "value": "0xb80b000000000000",
              "docs": [
                " The minimum period between blocks. Beware that this is different to the *expected* period",
                " that the block production apparatus provides. Your chosen consensus system will generally",
                " work with this to determine a sensible block time. e.g. For Aura, it will be double this",
                " period on default settings."
              ]
            }
          ],
          "errors": [],
          "index": 2
        },
        {
          "name": "Aura",
          "storage": null,
          "calls": null,
          "events": null,
          "constants": [],
          "errors": [],
          "index": 3
        },
        {
          "name": "Grandpa",
          "storage": {
            "prefix": "Grandpa",
            "items": [
              {
                "name": "State",
                "modifier": "Default",
                "type": {
                  "plain": "StoredState"
                },
                "fallback": "0x00",
                "docs": [
                  " State of the current authority set."
                ]
              },
              {
                "name": "PendingChange",
                "modifier": "Optional",
                "type": {
                  "plain": "StoredPendingChange"
                },
                "fallback": "0x00",
                "docs": [
                  " Pending change: (signaled at, scheduled change)."
                ]
              },
              {
                "name": "NextForced",
                "modifier": "Optional",
                "type": {
                  "plain": "BlockNumber"
                },
                "fallback": "0x00",
                "docs": [
                  " next block number where we can force a change."
                ]
              },
              {
                "name": "Stalled",
                "modifier": "Optional",
                "type": {
                  "plain": "(BlockNumber,BlockNumber)"
                },
                "fallback": "0x00",
                "docs": [
                  " `true` if we are currently stalled."
                ]
              },
              {
                "name": "CurrentSetId",
                "modifier": "Default",
                "type": {
                  "plain": "SetId"
                },
                "fallback": "0x0000000000000000",
                "docs": [
                  " The number of changes (both in terms of keys and underlying economic responsibilities)",
                  " in the \"set\" of Grandpa validators from genesis."
                ]
              },
              {
                "name": "SetIdSession",
                "modifier": "Optional",
                "type": {
                  "map": {
                    "hasher": "Twox64Concat",
                    "key": "SetId",
                    "value": "SessionIndex",
                    "linked": false
                  }
                },
                "fallback": "0x00",
                "docs": [
                  " A mapping from grandpa set ID to the index of the *most recent* session for which its",
                  " members were responsible.",
                  "",
                  " TWOX-NOTE: `SetId` is not under user control."
                ]
              }
            ]
          },
          "calls": [
            {
              "name": "report_equivocation",
              "args": [
                {
                  "name": "equivocation_proof",
                  "type": "GrandpaEquivocationProof"
                },
                {
                  "name": "key_owner_proof",
                  "type": "KeyOwnerProof"
                }
              ],
              "docs": [
                " Report voter equivocation/misbehavior. This method will verify the",
                " equivocation proof and validate the given key ownership proof",
                " against the extracted offender. If both are valid, the offence",
                " will be reported."
              ]
            },
            {
              "name": "report_equivocation_unsigned",
              "args": [
                {
                  "name": "equivocation_proof",
                  "type": "GrandpaEquivocationProof"
                },
                {
                  "name": "key_owner_proof",
                  "type": "KeyOwnerProof"
                }
              ],
              "docs": [
                " Report voter equivocation/misbehavior. This method will verify the",
                " equivocation proof and validate the given key ownership proof",
                " against the extracted offender. If both are valid, the offence",
                " will be reported.",
                "",
                " This extrinsic must be called unsigned and it is expected that only",
                " block authors will call it (validated in `ValidateUnsigned`), as such",
                " if the block author is defined it will be defined as the equivocation",
                " reporter."
              ]
            },
            {
              "name": "note_stalled",
              "args": [
                {
                  "name": "delay",
                  "type": "BlockNumber"
                },
                {
                  "name": "best_finalized_block_number",
                  "type": "BlockNumber"
                }
              ],
              "docs": [
                " Note that the current authority set of the GRANDPA finality gadget has",
                " stalled. This will trigger a forced authority set change at the beginning",
                " of the next session, to be enacted `delay` blocks after that. The delay",
                " should be high enough to safely assume that the block signalling the",
                " forced change will not be re-orged (e.g. 1000 blocks). The GRANDPA voters",
                " will start the new authority set using the given finalized block as base.",
                " Only callable by root."
              ]
            }
          ],
          "events": [
            {
              "name": "NewAuthorities",
              "args": [
                "AuthorityList"
              ],
              "docs": [
                " New authority set has been applied. \\[authority_set\\]"
              ]
            },
            {
              "name": "Paused",
              "args": [],
              "docs": [
                " Current authority set has been paused."
              ]
            },
            {
              "name": "Resumed",
              "args": [],
              "docs": [
                " Current authority set has been resumed."
              ]
            }
          ],
          "constants": [],
          "errors": [
            {
              "name": "PauseFailed",
              "docs": [
                " Attempt to signal GRANDPA pause when the authority set isn't live",
                " (either paused or already pending pause)."
              ]
            },
            {
              "name": "ResumeFailed",
              "docs": [
                " Attempt to signal GRANDPA resume when the authority set isn't paused",
                " (either live or already pending resume)."
              ]
            },
            {
              "name": "ChangePending",
              "docs": [
                " Attempt to signal GRANDPA change with one already pending."
              ]
            },
            {
              "name": "TooSoon",
              "docs": [
                " Cannot signal forced change so soon after last."
              ]
            },
            {
              "name": "InvalidKeyOwnershipProof",
              "docs": [
                " A key ownership proof provided as part of an equivocation report is invalid."
              ]
            },
            {
              "name": "InvalidEquivocationProof",
              "docs": [
                " An equivocation proof provided as part of an equivocation report is invalid."
              ]
            },
            {
              "name": "DuplicateOffenceReport",
              "docs": [
                " A given equivocation report is valid but already previously reported."
              ]
            }
          ],
          "index": 4
        },
        {
          "name": "Balances",
          "storage": {
            "prefix": "Balances",
            "items": [
              {
                "name": "TotalIssuance",
                "modifier": "Default",
                "type": {
                  "plain": "Balance"
                },
                "fallback": "0x00000000000000000000000000000000",
                "docs": [
                  " The total units issued in the system."
                ]
              },
              {
                "name": "Account",
                "modifier": "Default",
                "type": {
                  "map": {
                    "hasher": "Blake2_128Concat",
                    "key": "AccountId",
                    "value": "AccountData",
                    "linked": false
                  }
                },
                "fallback": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
                "docs": [
                  " The balance of an account.",
                  "",
                  " NOTE: This is only used in the case that this pallet is used to store balances."
                ]
              },
              {
                "name": "Locks",
                "modifier": "Default",
                "type": {
                  "map": {
                    "hasher": "Blake2_128Concat",
                    "key": "AccountId",
                    "value": "Vec<BalanceLock>",
                    "linked": false
                  }
                },
                "fallback": "0x00",
                "docs": [
                  " Any liquidity locks on some account balances.",
                  " NOTE: Should only be accessed when setting, changing and freeing a lock."
                ]
              },
              {
                "name": "Reserves",
                "modifier": "Default",
                "type": {
                  "map": {
                    "hasher": "Blake2_128Concat",
                    "key": "AccountId",
                    "value": "Vec<ReserveData>",
                    "linked": false
                  }
                },
                "fallback": "0x00",
                "docs": [
                  " Named reserves on some account balances."
                ]
              },
              {
                "name": "StorageVersion",
                "modifier": "Default",
                "type": {
                  "plain": "Releases"
                },
                "fallback": "0x00",
                "docs": [
                  " Storage version of the pallet.",
                  "",
                  " This is set to v2.0.0 for new networks."
                ]
              }
            ]
          },
          "calls": [
            {
              "name": "transfer",
              "args": [
                {
                  "name": "dest",
                  "type": "LookupSource"
                },
                {
                  "name": "value",
                  "type": "Compact<Balance>"
                }
              ],
              "docs": [
                " Transfer some liquid free balance to another account.",
                "",
                " `transfer` will set the `FreeBalance` of the sender and receiver.",
                " It will decrease the total issuance of the system by the `TransferFee`.",
                " If the sender's account is below the existential deposit as a result",
                " of the transfer, the account will be reaped.",
                "",
                " The dispatch origin for this call must be `Signed` by the transactor.",
                "",
                " # <weight>",
                " - Dependent on arguments but not critical, given proper implementations for",
                "   input config types. See related functions below.",
                " - It contains a limited number of reads and writes internally and no complex computation.",
                "",
                " Related functions:",
                "",
                "   - `ensure_can_withdraw` is always called internally but has a bounded complexity.",
                "   - Transferring balances to accounts that did not exist before will cause",
                "      `T::OnNewAccount::on_new_account` to be called.",
                "   - Removing enough funds from an account will trigger `T::DustRemoval::on_unbalanced`.",
                "   - `transfer_keep_alive` works the same way as `transfer`, but has an additional",
                "     check that the transfer will not kill the origin account.",
                " ---------------------------------",
                " - Base Weight: 73.64 µs, worst case scenario (account created, account removed)",
                " - DB Weight: 1 Read and 1 Write to destination account",
                " - Origin account is already in memory, so no DB operations for them.",
                " # </weight>"
              ]
            },
            {
              "name": "set_balance",
              "args": [
                {
                  "name": "who",
                  "type": "LookupSource"
                },
                {
                  "name": "new_free",
                  "type": "Compact<Balance>"
                },
                {
                  "name": "new_reserved",
                  "type": "Compact<Balance>"
                }
              ],
              "docs": [
                " Set the balances of a given account.",
                "",
                " This will alter `FreeBalance` and `ReservedBalance` in storage. it will",
                " also decrease the total issuance of the system (`TotalIssuance`).",
                " If the new free or reserved balance is below the existential deposit,",
                " it will reset the account nonce (`frame_system::AccountNonce`).",
                "",
                " The dispatch origin for this call is `root`.",
                "",
                " # <weight>",
                " - Independent of the arguments.",
                " - Contains a limited number of reads and writes.",
                " ---------------------",
                " - Base Weight:",
                "     - Creating: 27.56 µs",
                "     - Killing: 35.11 µs",
                " - DB Weight: 1 Read, 1 Write to `who`",
                " # </weight>"
              ]
            },
            {
              "name": "force_transfer",
              "args": [
                {
                  "name": "source",
                  "type": "LookupSource"
                },
                {
                  "name": "dest",
                  "type": "LookupSource"
                },
                {
                  "name": "value",
                  "type": "Compact<Balance>"
                }
              ],
              "docs": [
                " Exactly as `transfer`, except the origin must be root and the source account may be",
                " specified.",
                " # <weight>",
                " - Same as transfer, but additional read and write because the source account is",
                "   not assumed to be in the overlay.",
                " # </weight>"
              ]
            },
            {
              "name": "transfer_keep_alive",
              "args": [
                {
                  "name": "dest",
                  "type": "LookupSource"
                },
                {
                  "name": "value",
                  "type": "Compact<Balance>"
                }
              ],
              "docs": [
                " Same as the [`transfer`] call, but with a check that the transfer will not kill the",
                " origin account.",
                "",
                " 99% of the time you want [`transfer`] instead.",
                "",
                " [`transfer`]: struct.Pallet.html#method.transfer",
                " # <weight>",
                " - Cheaper than transfer because account cannot be killed.",
                " - Base Weight: 51.4 µs",
                " - DB Weight: 1 Read and 1 Write to dest (sender is in overlay already)",
                " #</weight>"
              ]
            },
            {
              "name": "transfer_all",
              "args": [
                {
                  "name": "dest",
                  "type": "LookupSource"
                },
                {
                  "name": "keep_alive",
                  "type": "bool"
                }
              ],
              "docs": [
                " Transfer the entire transferable balance from the caller account.",
                "",
                " NOTE: This function only attempts to transfer _transferable_ balances. This means that",
                " any locked, reserved, or existential deposits (when `keep_alive` is `true`), will not be",
                " transferred by this function. To ensure that this function results in a killed account,",
                " you might need to prepare the account by removing any reference counters, storage",
                " deposits, etc...",
                "",
                " The dispatch origin of this call must be Signed.",
                "",
                " - `dest`: The recipient of the transfer.",
                " - `keep_alive`: A boolean to determine if the `transfer_all` operation should send all",
                "   of the funds the account has, causing the sender account to be killed (false), or",
                "   transfer everything except at least the existential deposit, which will guarantee to",
                "   keep the sender account alive (true).",
                "   # <weight>",
                " - O(1). Just like transfer, but reading the user's transferable balance first.",
                "   #</weight>"
              ]
            }
          ],
          "events": [
            {
              "name": "Endowed",
              "args": [
                "AccountId",
                "Balance"
              ],
              "docs": [
                " An account was created with some free balance. \\[account, free_balance\\]"
              ]
            },
            {
              "name": "DustLost",
              "args": [
                "AccountId",
                "Balance"
              ],
              "docs": [
                " An account was removed whose balance was non-zero but below ExistentialDeposit,",
                " resulting in an outright loss. \\[account, balance\\]"
              ]
            },
            {
              "name": "Transfer",
              "args": [
                "AccountId",
                "AccountId",
                "Balance"
              ],
              "docs": [
                " Transfer succeeded. \\[from, to, value\\]"
              ]
            },
            {
              "name": "BalanceSet",
              "args": [
                "AccountId",
                "Balance",
                "Balance"
              ],
              "docs": [
                " A balance was set by root. \\[who, free, reserved\\]"
              ]
            },
            {
              "name": "Deposit",
              "args": [
                "AccountId",
                "Balance"
              ],
              "docs": [
                " Some amount was deposited (e.g. for transaction fees). \\[who, deposit\\]"
              ]
            },
            {
              "name": "Reserved",
              "args": [
                "AccountId",
                "Balance"
              ],
              "docs": [
                " Some balance was reserved (moved from free to reserved). \\[who, value\\]"
              ]
            },
            {
              "name": "Unreserved",
              "args": [
                "AccountId",
                "Balance"
              ],
              "docs": [
                " Some balance was unreserved (moved from reserved to free). \\[who, value\\]"
              ]
            },
            {
              "name": "ReserveRepatriated",
              "args": [
                "AccountId",
                "AccountId",
                "Balance",
                "BalanceStatus"
              ],
              "docs": [
                " Some balance was moved from the reserve of the first account to the second account.",
                " Final argument indicates the destination balance type.",
                " \\[from, to, balance, destination_status\\]"
              ]
            }
          ],
          "constants": [
            {
              "name": "ExistentialDeposit",
              "type": "Balance",
              "value": "0xf4010000000000000000000000000000",
              "docs": [
                " The minimum amount required to keep an account open."
              ]
            }
          ],
          "errors": [
            {
              "name": "VestingBalance",
              "docs": [
                " Vesting balance too high to send value"
              ]
            },
            {
              "name": "LiquidityRestrictions",
              "docs": [
                " Account liquidity restrictions prevent withdrawal"
              ]
            },
            {
              "name": "InsufficientBalance",
              "docs": [
                " Balance too low to send value"
              ]
            },
            {
              "name": "ExistentialDeposit",
              "docs": [
                " Value too low to create account due to existential deposit"
              ]
            },
            {
              "name": "KeepAlive",
              "docs": [
                " Transfer/payment would kill account"
              ]
            },
            {
              "name": "ExistingVestingSchedule",
              "docs": [
                " A vesting schedule already exists for this account"
              ]
            },
            {
              "name": "DeadAccount",
              "docs": [
                " Beneficiary account must pre-exist"
              ]
            },
            {
              "name": "TooManyReserves",
              "docs": [
                " Number of named reserves exceed MaxReserves"
              ]
            }
          ],
          "index": 5
        },
        {
          "name": "TransactionPayment",
          "storage": {
            "prefix": "TransactionPayment",
            "items": [
              {
                "name": "NextFeeMultiplier",
                "modifier": "Default",
                "type": {
                  "plain": "Multiplier"
                },
                "fallback": "0x000064a7b3b6e00d0000000000000000",
                "docs": []
              },
              {
                "name": "StorageVersion",
                "modifier": "Default",
                "type": {
                  "plain": "Releases"
                },
                "fallback": "0x00",
                "docs": []
              }
            ]
          },
          "calls": null,
          "events": null,
          "constants": [
            {
              "name": "TransactionByteFee",
              "type": "BalanceOf",
              "value": "0x01000000000000000000000000000000",
              "docs": [
                " The fee to be paid for making a transaction; the per-byte portion."
              ]
            },
            {
              "name": "WeightToFee",
              "type": "Vec<WeightToFeeCoefficient>",
              "value": "0x0401000000000000000000000000000000000000000001",
              "docs": [
                " The polynomial that is applied in order to derive fee from weight."
              ]
            }
          ],
          "errors": [],
          "index": 6
        },
        {
          "name": "Sudo",
          "storage": {
            "prefix": "Sudo",
            "items": [
              {
                "name": "Key",
                "modifier": "Default",
                "type": {
                  "plain": "AccountId"
                },
                "fallback": "0x0000000000000000000000000000000000000000000000000000000000000000",
                "docs": [
                  " The `AccountId` of the sudo key."
                ]
              }
            ]
          },
          "calls": [
            {
              "name": "sudo",
              "args": [
                {
                  "name": "call",
                  "type": "Call"
                }
              ],
              "docs": [
                " Authenticates the sudo key and dispatches a function call with `Root` origin.",
                "",
                " The dispatch origin for this call must be _Signed_.",
                "",
                " # <weight>",
                " - O(1).",
                " - Limited storage reads.",
                " - One DB write (event).",
                " - Weight of derivative `call` execution + 10,000.",
                " # </weight>"
              ]
            },
            {
              "name": "sudo_unchecked_weight",
              "args": [
                {
                  "name": "call",
                  "type": "Call"
                },
                {
                  "name": "_weight",
                  "type": "Weight"
                }
              ],
              "docs": [
                " Authenticates the sudo key and dispatches a function call with `Root` origin.",
                " This function does not check the weight of the call, and instead allows the",
                " Sudo user to specify the weight of the call.",
                "",
                " The dispatch origin for this call must be _Signed_.",
                "",
                " # <weight>",
                " - O(1).",
                " - The weight of this call is defined by the caller.",
                " # </weight>"
              ]
            },
            {
              "name": "set_key",
              "args": [
                {
                  "name": "new",
                  "type": "LookupSource"
                }
              ],
              "docs": [
                " Authenticates the current sudo key and sets the given AccountId (`new`) as the new sudo key.",
                "",
                " The dispatch origin for this call must be _Signed_.",
                "",
                " # <weight>",
                " - O(1).",
                " - Limited storage reads.",
                " - One DB change.",
                " # </weight>"
              ]
            },
            {
              "name": "sudo_as",
              "args": [
                {
                  "name": "who",
                  "type": "LookupSource"
                },
                {
                  "name": "call",
                  "type": "Call"
                }
              ],
              "docs": [
                " Authenticates the sudo key and dispatches a function call with `Signed` origin from",
                " a given account.",
                "",
                " The dispatch origin for this call must be _Signed_.",
                "",
                " # <weight>",
                " - O(1).",
                " - Limited storage reads.",
                " - One DB write (event).",
                " - Weight of derivative `call` execution + 10,000.",
                " # </weight>"
              ]
            }
          ],
          "events": [
            {
              "name": "Sudid",
              "args": [
                "DispatchResult"
              ],
              "docs": [
                " A sudo just took place. \\[result\\]"
              ]
            },
            {
              "name": "KeyChanged",
              "args": [
                "AccountId"
              ],
              "docs": [
                " The \\[sudoer\\] just switched identity; the old key is supplied."
              ]
            },
            {
              "name": "SudoAsDone",
              "args": [
                "DispatchResult"
              ],
              "docs": [
                " A sudo just took place. \\[result\\]"
              ]
            }
          ],
          "constants": [],
          "errors": [
            {
              "name": "RequireSudo",
              "docs": [
                " Sender must be the Sudo account"
              ]
            }
          ],
          "index": 7
        },
        {
          "name": "TemplateModule",
          "storage": {
            "prefix": "TemplateModule",
            "items": [
              {
                "name": "Something",
                "modifier": "Optional",
                "type": {
                  "plain": "u32"
                },
                "fallback": "0x00",
                "docs": []
              }
            ]
          },
          "calls": [
            {
              "name": "do_something",
              "args": [
                {
                  "name": "something",
                  "type": "u32"
                }
              ],
              "docs": [
                " An example dispatchable that takes a singles value as a parameter, writes the value to",
                " storage and emits an event. This function must be dispatched by a signed extrinsic."
              ]
            },
            {
              "name": "cause_error",
              "args": [],
              "docs": [
                " An example dispatchable that may throw a custom error."
              ]
            }
          ],
          "events": [
            {
              "name": "SomethingStored",
              "args": [
                "u32",
                "AccountId"
              ],
              "docs": [
                " Event documentation should end with an array that provides descriptive names for event",
                " parameters. [something, who]"
              ]
            }
          ],
          "constants": [],
          "errors": [
            {
              "name": "NoneValue",
              "docs": [
                " Error names should be descriptive."
              ]
            },
            {
              "name": "StorageOverflow",
              "docs": [
                " Errors should have helpful documentation associated with them."
              ]
            }
          ],
          "index": 8
        },
        {
          "name": "PoeModule",
          "storage": {
            "prefix": "PoeModule",
            "items": [
              {
                "name": "Proofs",
                "modifier": "Optional",
                "type": {
                  "map": {
                    "hasher": "Blake2_128Concat",
                    "key": "Bytes",
                    "value": "(AccountId,BlockNumber)",
                    "linked": false
                  }
                },
                "fallback": "0x00",
                "docs": []
              }
            ]
          },
          "calls": [
            {
              "name": "create_claim",
              "args": [
                {
                  "name": "claim",
                  "type": "Bytes"
                }
              ],
              "docs": []
            },
            {
              "name": "revoke_claim",
              "args": [
                {
                  "name": "claim",
                  "type": "Bytes"
                }
              ],
              "docs": []
            },
            {
              "name": "transfer_claim",
              "args": [
                {
                  "name": "claim",
                  "type": "Bytes"
                },
                {
                  "name": "rec_account",
                  "type": "AccountId"
                }
              ],
              "docs": []
            }
          ],
          "events": [
            {
              "name": "ClaimCreated",
              "args": [
                "AccountId",
                "Bytes"
              ],
              "docs": []
            },
            {
              "name": "ClaimRevoked",
              "args": [
                "AccountId",
                "Bytes"
              ],
              "docs": []
            },
            {
              "name": "ClaimTransfered",
              "args": [
                "AccountId",
                "Bytes"
              ],
              "docs": []
            }
          ],
          "constants": [],
          "errors": [
            {
              "name": "ProofAlreadyExist",
              "docs": []
            },
            {
              "name": "ClaimNotExist",
              "docs": []
            },
            {
              "name": "NotClaimOwner",
              "docs": []
            },
            {
              "name": "ClaimOutLength",
              "docs": []
            }
          ],
          "index": 9
        },
        {
          "name": "KittiesModule",
          "storage": {
            "prefix": "KittiesModule",
            "items": [
              {
                "name": "KittiesCount",
                "modifier": "Optional",
                "type": {
                  "plain": "KittyIndex"
                },
                "fallback": "0x00",
                "docs": [
                  " 定义存储",
                  " 1. 要记录kitties的index，首先需要记录kitties的数量，这样才能知道写一个kitty的id是多少"
                ]
              },
              {
                "name": "Kitties",
                "modifier": "Default",
                "type": {
                  "map": {
                    "hasher": "Blake2_128Concat",
                    "key": "KittyIndex",
                    "value": "Option<Kitty>",
                    "linked": false
                  }
                },
                "fallback": "0x00",
                "docs": [
                  " 2. 每个kitty都有自己的数据",
                  " kittyIndex作为key，kitty的数据作为value",
                  " 使用Blake2_128Concat作为Hash函数的方法"
                ]
              },
              {
                "name": "Owner",
                "modifier": "Default",
                "type": {
                  "map": {
                    "hasher": "Blake2_128Concat",
                    "key": "KittyIndex",
                    "value": "Option<AccountId>",
                    "linked": false
                  }
                },
                "fallback": "0x00",
                "docs": [
                  " 3. 每个kitty的所有者owner",
                  " kittyIndex作为key，AccountId作为value"
                ]
              },
              {
                "name": "KittyMarket",
                "modifier": "Default",
                "type": {
                  "map": {
                    "hasher": "Blake2_128Concat",
                    "key": "KittyIndex",
                    "value": "BalanceOf",
                    "linked": false
                  }
                },
                "fallback": "0x00000000000000000000000000000000",
                "docs": [
                  " 4.定义一个kitty交易市场，用来对需要卖的kitty进行挂单",
                  " kittyindex为key,挂单的金额为value"
                ]
              }
            ]
          },
          "calls": [
            {
              "name": "create",
              "args": [],
              "docs": [
                " 创建kitty"
              ]
            },
            {
              "name": "transfer",
              "args": [
                {
                  "name": "new_owner",
                  "type": "AccountId"
                },
                {
                  "name": "kitty_id",
                  "type": "KittyIndex"
                }
              ],
              "docs": [
                " 转移Kitty的所有者",
                " para1： 新的owner",
                " para2:  需要转移的kitty_id"
              ]
            },
            {
              "name": "breed",
              "args": [
                {
                  "name": "kitty_id_1",
                  "type": "KittyIndex"
                },
                {
                  "name": "kitty_id_2",
                  "type": "KittyIndex"
                }
              ],
              "docs": [
                " 繁殖kitty",
                " para1: 父kitty",
                " para2: 母kitty"
              ]
            },
            {
              "name": "sell_kitties",
              "args": [
                {
                  "name": "kitty_id",
                  "type": "KittyIndex"
                },
                {
                  "name": "selling_value",
                  "type": "BalanceOf"
                }
              ],
              "docs": [
                " 卖Kitty，将需要卖的kittyIndex放进kittymarket进行挂单"
              ]
            },
            {
              "name": "buy_kitties",
              "args": [
                {
                  "name": "kitty_id",
                  "type": "KittyIndex"
                }
              ],
              "docs": [
                " 买kitty，从kittymarket接单，买入"
              ]
            }
          ],
          "events": [
            {
              "name": "KittyCreate",
              "args": [
                "AccountId",
                "KittyIndex"
              ],
              "docs": []
            },
            {
              "name": "KittyTransfer",
              "args": [
                "AccountId",
                "AccountId",
                "KittyIndex"
              ],
              "docs": []
            },
            {
              "name": "SellingKitty",
              "args": [
                "KittyIndex",
                "BalanceOf"
              ],
              "docs": []
            },
            {
              "name": "SeltKitty",
              "args": [
                "KittyIndex",
                "AccountId",
                "AccountId"
              ],
              "docs": []
            }
          ],
          "constants": [],
          "errors": [
            {
              "name": "KittiesCountOverflow",
              "docs": [
                " kittyId溢出错误"
              ]
            },
            {
              "name": "NotOwner",
              "docs": [
                " 不是kittyId的owner"
              ]
            },
            {
              "name": "SameParentIndex",
              "docs": [
                " 两个相同的祖先"
              ]
            },
            {
              "name": "InvalidKittyIndex",
              "docs": [
                " 指定的KittyIndex的数据不存在"
              ]
            },
            {
              "name": "NoSufficientBalance",
              "docs": [
                " 没有足够的质押金额"
              ]
            }
          ],
          "index": 10
        }
      ],
      "extrinsic": {
        "version": 4,
        "signedExtensions": [
          "CheckSpecVersion",
          "CheckTxVersion",
          "CheckGenesis",
          "CheckMortality",
          "CheckNonce",
          "CheckWeight",
          "ChargeTransactionPayment"
        ]
      }
    }
  }
}
Tx status: Ready
Subscribed to Alice account.
Alice Account (sub): 1150921504356846680
Tx status: {"inBlock":"0x7f1c5a395897cf8fa9464156c34fdb98de7d0a3766b64bfa82057b9819cb1e8b"}
Tx status: {"finalized":"0x7f1c5a395897cf8fa9464156c34fdb98de7d0a3766b64bfa82057b9819cb1e8b"}
successfully exited
Done in 21.78s.
